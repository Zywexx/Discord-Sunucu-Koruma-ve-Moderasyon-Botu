require('dotenv').config();
const fs = require('fs');
const path = require('path');
const {
  Client,
  GatewayIntentBits,
  Partials,
  EmbedBuilder,
  AuditLogEvent,
  PermissionFlagsBits,
  ActivityType,
  ChannelType,
  Collection
} = require('discord.js');

// ===================== CONFIGURATION =====================
// Varsayƒ±lan yapƒ±landƒ±rma
const DEFAULT_CONFIG = {
  prefix: '!',
  ownerID: '987664359285219348', // Owner ID
  logChannel: '1413509831645462668', // Log channel ID
  
  
  inviteBlock: true,
  dangerousRoleGuard: true,
  botAddProtection: true,
  boosterProtection: true,
  vanityProtection: true,
  webhookProtection: true,
  spamProtection: true,
  profanityFilter: true,
  linkBlock: true,
  
  // Limits
  channelDeleteLimit: 3,
  roleDeleteLimit: 3,
  forbiddenPermissionLimit: 3,
  nonWhitelistBanLimit: 2,
  spamLimit: 5,
  spamInterval: 5000,
  
  
  forbiddenPermissions: [
    PermissionFlagsBits.Administrator,
    PermissionFlagsBits.BanMembers,
    PermissionFlagsBits.KickMembers,
    PermissionFlagsBits.ManageGuild,
    PermissionFlagsBits.ManageChannels,
    PermissionFlagsBits.ManageRoles,
    PermissionFlagsBits.ModerateMembers,
    PermissionFlagsBits.ManageWebhooks,
    PermissionFlagsBits.MentionEveryone
  ],
  
  
  profanities: [
    'amk', 'aq', 'pi√ß', 'g√∂t', 'sik', 'yarrak', 'amcƒ±k', 
    'oruspu', 'sikerim', 'siktir', 'ananƒ±', 'ananƒ± sikim'
  ],
  
 
  muteRoleName: 'Susturulmu≈ü',
  
  
  autoMute: true,
  warningSystem: true,
  autoLogging: true,
  backupSystem: true
};


function loadConfig() {
  try {
    
    if (fs.existsSync('./bot-config.json')) {
      const userConfigData = fs.readFileSync('./bot-config.json', 'utf8');
      const userConfig = JSON.parse(userConfigData);
      
      
      const mergedConfig = { ...DEFAULT_CONFIG, ...userConfig };
      console.log('‚úÖ Kullanƒ±cƒ± yapƒ±landƒ±rmasƒ± ba≈üarƒ±yla y√ºklendi.');
      return mergedConfig;
    }
  } catch (error) {
    console.error('‚ùå Yapƒ±landƒ±rma dosyasƒ± y√ºklenirken hata:', error);
  }
  
  
  console.log('‚ÑπÔ∏è Kullanƒ±cƒ± yapƒ±landƒ±rmasƒ± bulunamadƒ±, varsayƒ±lan ayarlar kullanƒ±lƒ±yor.');
  return DEFAULT_CONFIG;
}


let CONFIG = loadConfig();


const ROOT_DIR = __dirname;
const DATA_DIR = path.join(ROOT_DIR, 'data');
const BACKUP_DIR = path.join(ROOT_DIR, 'backups');
const WHITELIST_FILE = path.join(DATA_DIR, 'whitelist.json');
const MUTES_FILE = path.join(DATA_DIR, 'mutes.json');
const WARNINGS_FILE = path.join(DATA_DIR, 'warnings.json');
const BANCOUNT_FILE = path.join(DATA_DIR, 'bancount.json');
const VANITY_FILE = path.join(DATA_DIR, 'vanity.json');


if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR);
if (!fs.existsSync(BACKUP_DIR)) fs.mkdirSync(BACKUP_DIR);


function loadJSON(file, fallback) {
  try {
    if (fs.existsSync(file)) {
      return JSON.parse(fs.readFileSync(file, 'utf8'));
    }
  } catch (error) {
    console.error(`Error loading ${file}:`, error);
  }
  return fallback;
}

function saveJSON(file, data) {
  try {
    fs.writeFileSync(file, JSON.stringify(data, null, 2), 'utf8');
  } catch (error) {
    console.error(`Error saving ${file}:`, error);
  }
}


let whitelist = loadJSON(WHITELIST_FILE, { guilds: {} });
let mutes = loadJSON(MUTES_FILE, { guilds: {} });
let warnings = loadJSON(WARNINGS_FILE, { guilds: {} });
let bancount = loadJSON(BANCOUNT_FILE, { guilds: {} });
let vanityStore = loadJSON(VANITY_FILE, { guilds: {} });


function mention(id) {
  return `<@${id}>`;
}

function logChannel(guild) {
  return CONFIG.logChannel ? guild.channels.cache.get(CONFIG.logChannel) : null;
}

async function sendLog(guild, embed) {
  try {
    const channel = logChannel(guild);
    if (channel && CONFIG.autoLogging) await channel.send({ embeds: [embed] });
  } catch (error) {
    console.error('Error sending log:', error);
  }
}

function parseDuration(str) {
  if (!str) return null;
  const match = str.match(/^(\d+)(s|d|sa|g)$/i);
  if (!match) return null;
  
  const num = parseInt(match[1], 10);
  const unit = match[2].toLowerCase();
  
  switch (unit) {
    case 's': return num * 1000;
    case 'd': return num * 60 * 1000;
    case 'sa': return num * 60 * 60 * 1000;
    case 'g': return num * 24 * 60 * 60 * 1000;
    default: return null;
  }
}

function msToDuration(ms) {
  if (ms <= 0) return 'bitti';
  
  const seconds = Math.floor(ms / 1000) % 60;
  const minutes = Math.floor(ms / 60000) % 60;
  const hours = Math.floor(ms / 3600000) % 24;
  const days = Math.floor(ms / 86400000);
  
  return `${days ? `${days}g ` : ''}${hours ? `${hours}sa ` : ''}${minutes ? `${minutes}d ` : ''}${seconds}s`;
}

function isWhitelisted(guildId, userId) {
  if (!whitelist.guilds[guildId]) {
    whitelist.guilds[guildId] = { users: [] };
  }
  return userId === CONFIG.ownerID || whitelist.guilds[guildId].users.includes(userId);
}

function ensureGuildStructure(store, guildId) {
  if (!store.guilds[guildId]) {
    store.guilds[guildId] = { users: [], records: {}, count: {} };
  }
  
  if (store === bancount && !store.guilds[guildId].count) {
    store.guilds[guildId].count = {};
  }
  
  if (store === vanityStore && store.guilds[guildId].vanity === undefined) {
    store.guilds[guildId].vanity = null;
  }
  
  if (store === mutes && !store.guilds[guildId].records) {
    store.guilds[guildId].records = {};
  }
  
  if (store === warnings && !store.guilds[guildId].records) {
    store.guilds[guildId].records = {};
  }
}


const userActions = new Map();

function addAction(userId, type, limit) {
  if (!userActions.has(userId)) {
    userActions.set(userId, { channel: 0, role: 0, permission: 0 });
  }
  
  const actions = userActions.get(userId);
  actions[type]++;
  
  return actions[type] >= limit;
}


async function punishUser(guild, userId, reason) {
  try {
    const member = await guild.members.fetch(userId).catch(() => null);
    if (!member) return;
    
    await member.roles.set([], reason).catch(() => {});
    
    const embed = new EmbedBuilder()
      .setColor(0xff0000)
      .setTitle('üö® Koruma Sistemi: Limit A≈üƒ±ldƒ±')
      .setDescription(`${mention(userId)} t√ºm rolleri alƒ±ndƒ±.\n**Sebep:** ${reason}`)
      .setTimestamp();
    
    await sendLog(guild, embed);
  } catch (error) {
    console.error('Error punishing user:', error);
  }
}


async function createMuteRole(guild) {
  try {
    let role = guild.roles.cache.find(r => r.name === CONFIG.muteRoleName);
    
    if (!role) {
      role = await guild.roles.create({
        name: CONFIG.muteRoleName,
        permissions: [],
        reason: 'Otomatik mute rol√º'
      });
    }
    
    if (!role) return null;
    
    
    const permissions = {
      SendMessages: false,
      AddReactions: false,
      SendMessagesInThreads: false,
      CreatePublicThreads: false,
      CreatePrivateThreads: false,
      Speak: false,
      Connect: false
    };
    
    for (const [_, channel] of guild.channels.cache) {
      try {
        if (channel.isTextBased()) {
          await channel.permissionOverwrites.edit(role, {
            SendMessages: false,
            AddReactions: false,
            SendMessagesInThreads: false,
            CreatePublicThreads: false,
            CreatePrivateThreads: false
          }).catch(() => {});
        } else if (channel.isVoiceBased()) {
          await channel.permissionOverwrites.edit(role, {
            Speak: false,
            Connect: false
          }).catch(() => {});
        }
      } catch (error) {
        console.error('Error applying mute role to channel:', error);
      }
    }
    
    return role;
  } catch (error) {
    console.error('Error creating mute role:', error);
    return null;
  }
}

async function applyMuteRoleToNewChannel(channel) {
  try {
    const role = channel.guild.roles.cache.find(r => r.name === CONFIG.muteRoleName);
    if (!role) return;
    
    if (channel.isTextBased()) {
      await channel.permissionOverwrites.edit(role, {
        SendMessages: false,
        AddReactions: false,
        SendMessagesInThreads: false,
        CreatePublicThreads: false,
        CreatePrivateThreads: false
      }).catch(() => {});
    } else if (channel.isVoiceBased()) {
      await channel.permissionOverwrites.edit(role, {
        Speak: false,
        Connect: false
      }).catch(() => {});
    }
  } catch (error) {
    console.error('Error applying mute role to new channel:', error);
  }
}

async function applyMute(guild, moderator, targetId, durationMs, reason) {
  try {
    if (!CONFIG.autoMute) return;
    
    ensureGuildStructure(mutes, guild.id);
    const muteRole = await createMuteRole(guild);
    if (!muteRole) return;
    
    const target = await guild.members.fetch(targetId).catch(() => null);
    if (!target) return;
    
    
    if (!target.roles.cache.has(muteRole.id)) {
      await target.roles.add(muteRole, reason || 'Mute').catch(() => {});
    }
    
    const endTime = durationMs ? Date.now() + durationMs : null;
    mutes.guilds[guild.id].records[targetId] = { reason, endTime };
    saveJSON(MUTES_FILE, mutes);
    
    const embed = new EmbedBuilder()
      .setColor(0x5555ff)
      .setTitle('üîá Susturuldu')
      .addFields(
        { name: 'Kullanƒ±cƒ±', value: `${mention(targetId)} (${targetId})`, inline: true },
        { name: 'Yetkili', value: `${mention(moderator.id)} (${moderator.id})`, inline: true },
        { name: 'S√ºre', value: endTime ? msToDuration(endTime - Date.now()) : 'Sƒ±nƒ±rsƒ±z', inline: true },
        { name: 'Sebep', value: reason || 'Belirtilmedi', inline: false }
      )
      .setTimestamp();
    
    await sendLog(guild, embed);
  } catch (error) {
    console.error('Error applying mute:', error);
  }
}

async function removeMute(guild, moderator, targetId, reason = 'Unmute') {
  try {
    ensureGuildStructure(mutes, guild.id);
    const muteRole = guild.roles.cache.find(r => r.name === CONFIG.muteRoleName);
    const target = await guild.members.fetch(targetId).catch(() => null);
    
    if (target && muteRole && target.roles.cache.has(muteRole.id)) {
      await target.roles.remove(muteRole, reason).catch(() => {});
    }
    
    
    if (mutes.guilds[guild.id]?.records?.[targetId]) {
      delete mutes.guilds[guild.id].records[targetId];
      saveJSON(MUTES_FILE, mutes);
    }
    
    const embed = new EmbedBuilder()
      .setColor(0x77ddff)
      .setTitle('üîä Susturma Kaldƒ±rƒ±ldƒ±')
      .addFields(
        { name: 'Kullanƒ±cƒ±', value: `${mention(targetId)} (${targetId})`, inline: true },
        { name: 'Yetkili', value: `${mention(moderator.id)} (${moderator.id})`, inline: true }
      )
      .setTimestamp();
    
    await sendLog(guild, embed);
  } catch (error) {
    console.error('Error removing mute:', error);
  }
}


async function addWarning(guild, moderator, targetId, reason) {
  try {
    if (!CONFIG.warningSystem) return;
    
    ensureGuildStructure(warnings, guild.id);
    
    if (!warnings.guilds[guild.id].records[targetId]) {
      warnings.guilds[guild.id].records[targetId] = [];
    }
    
    const warning = {
      reason,
      moderatorId: moderator.id,
      time: Date.now()
    };
    
    warnings.guilds[guild.id].records[targetId].push(warning);
    saveJSON(WARNINGS_FILE, warnings);
    
    const embed = new EmbedBuilder()
      .setColor(0xffaa00)
      .setTitle('‚ö†Ô∏è Uyarƒ± Verildi')
      .addFields(
        { name: 'Kullanƒ±cƒ±', value: `${mention(targetId)} (${targetId})`, inline: true },
        { name: 'Yetkili', value: `${mention(moderator.id)} (${moderator.id})`, inline: true },
        { name: 'Sebep', value: reason, inline: false },
        { name: 'Toplam Uyarƒ±', value: warnings.guilds[guild.id].records[targetId].length, inline: true }
      )
      .setTimestamp();
    
    await sendLog(guild, embed);
  } catch (error) {
    console.error('Error adding warning:', error);
  }
}

async function removeWarning(guild, moderator, targetId, warningIndex) {
  try {
    if (!CONFIG.warningSystem) return false;
    
    ensureGuildStructure(warnings, guild.id);
    
    if (!warnings.guilds[guild.id].records[targetId] || 
        warningIndex < 1 || 
        warningIndex > warnings.guilds[guild.id].records[targetId].length) {
      return false;
    }
    
    const removedWarning = warnings.guilds[guild.id].records[targetId].splice(warningIndex - 1, 1)[0];
    saveJSON(WARNINGS_FILE, warnings);
    
    const embed = new EmbedBuilder()
      .setColor(0x77dd77)
      .setTitle('‚ôªÔ∏è Uyarƒ± Kaldƒ±rƒ±ldƒ±')
      .addFields(
        { name: 'Kullanƒ±cƒ±', value: `${mention(targetId)} (${targetId})`, inline: true },
        { name: 'Yetkili', value: `${mention(moderator.id)} (${moderator.id})`, inline: true },
        { name: 'Kaldƒ±rƒ±lan Uyarƒ±', value: removedWarning.reason, inline: false }
      )
      .setTimestamp();
    
    await sendLog(guild, embed);
    return true;
  } catch (error) {
    console.error('Error removing warning:', error);
    return false;
  }
}


async function backupGuild(guild) {
  try {
    if (!CONFIG.backupSystem) return null;
    
    const data = {
      guildId: guild.id,
      timestamp: new Date().toISOString(),
      roles: [],
      channels: []
    };
    
    guild.roles.cache.forEach(role => {
      data.roles.push({
        name: role.name,
        permissions: role.permissions.bitfield.toString(),
        color: role.color,
        hoist: role.hoist,
        mentionable: role.mentionable,
        managed: role.managed,
        position: role.position
      });
    });
    
    guild.channels.cache.forEach(channel => {
      data.channels.push({
        name: channel.name,
        type: channel.type,
        parentId: channel.parentId,
        position: channel.rawPosition
      });
    });
    
    const file = path.join(BACKUP_DIR, `${guild.id}_${Date.now()}.json`);
    saveJSON(file, data);
    return file;
  } catch (error) {
    console.error('Error backing up guild:', error);
    return null;
  }
}

async function restoreGuild(guild, mode) {
  try {
    if (!CONFIG.backupSystem) return;
    
    const backupFiles = fs.readdirSync(BACKUP_DIR)
      .filter(file => file.startsWith(guild.id))
      .sort()
      .reverse();
    
    if (!backupFiles.length) return;
    
    const file = path.join(BACKUP_DIR, backupFiles[0]);
    const data = loadJSON(file);
    if (!data) return;
    
    const needRole = (r) => !guild.roles.cache.find(x => x.name === r.name);
    const needChannel = (c) => !guild.channels.cache.find(x => x.name === c.name);
    
    for (const role of data.roles) {
      if (needRole(role)) {
        await guild.roles.create({
          name: role.name,
          permissions: BigInt(role.permissions),
          color: role.color
        }).catch(() => {});
      }
    }
    
    for (const channel of data.channels) {
      if (needChannel(channel)) {
        await guild.channels.create({
          name: channel.name,
          type: channel.type,
          parent: channel.parentId
        }).catch(() => {});
      }
    }
  } catch (error) {
    console.error('Error restoring guild:', error);
  }
}


const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildBans,
    GatewayIntentBits.GuildEmojisAndStickers,
    GatewayIntentBits.GuildIntegrations,
    GatewayIntentBits.GuildWebhooks,
    GatewayIntentBits.GuildInvites,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildPresences,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.GuildMessageTyping,
    GatewayIntentBits.DirectMessages,
    GatewayIntentBits.DirectMessageReactions,
    GatewayIntentBits.DirectMessageTyping,
    GatewayIntentBits.MessageContent
  ],
  partials: [Partials.Channel, Partials.Message, Partials.User, Partials.GuildMember, Partials.Reaction]
});


client.commands = new Collection();


const commands = [
  {
    name: 'yardim',
    description: 'Yardƒ±m men√ºs√ºn√º g√∂sterir',
    permissions: [],
    async execute(client, message, args) {
      
      const categories = {
        moderasyon: [
          { name: 'ban', usage: '<kullanƒ±cƒ±> [sebep]', description: 'Kullanƒ±cƒ±yƒ± banlar' },
          { name: 'unban', usage: '<kullanƒ±cƒ±-id>', description: 'Banƒ± kaldƒ±rƒ±r' },
          { name: 'kick', usage: '<kullanƒ±cƒ±> [sebep]', description: 'Kullanƒ±cƒ±yƒ± atar' },
          { name: 'mute', usage: '<kullanƒ±cƒ±> [s√ºre] [sebep]', description: 'Kullanƒ±cƒ±yƒ± susturur' },
          { name: 'unmute', usage: '<kullanƒ±cƒ±>', description: 'Susturmayƒ± kaldƒ±rƒ±r' },
          { name: 'uyar', usage: '<kullanƒ±cƒ±> <sebep>', description: 'Kullanƒ±cƒ±ya uyarƒ± verir' },
          { name: 'uyarƒ±kaldir', usage: '<kullanƒ±cƒ±> <numara>', description: 'Uyarƒ±yƒ± kaldƒ±rƒ±r' },
          { name: 'uyarƒ±lar', usage: '<kullanƒ±cƒ±>', description: 'Kullanƒ±cƒ±nƒ±n uyarƒ±larƒ±nƒ± g√∂sterir' },
          { name: 'temizle', usage: '<miktar>', description: 'Mesajlarƒ± siler' },
          { name: 'yava≈ümod', usage: '<saniye>', description: 'Kanal i√ßin yava≈ü mod ayarlar' },
          { name: 'kilitle', usage: '[sebep]', description: 'Kanalƒ± kilitler' },
          { name: 'kilida√ß', usage: '[sebep]', description: 'Kanal kilidini a√ßar' }
        ],
        yonetim: [
          { name: 'rolver', usage: '<kullanƒ±cƒ±> <rol>', description: 'Kullanƒ±cƒ±ya rol verir' },
          { name: 'rolal', usage: '<kullanƒ±cƒ±> <rol>', description: 'Kullanƒ±cƒ±dan rol alƒ±r' },
          { name: 'kanalolu≈ütur', usage: '<isim> [tip]', description: 'Yeni kanal olu≈üturur' },
          { name: 'kanalsil', usage: '<kanal>', description: 'Kanal siler' },
          { name: 'rololu≈ütur', usage: '<isim> [renk]', description: 'Yeni rol olu≈üturur' },
          { name: 'rolsil', usage: '<rol>', description: 'Rol siler' },
          { name: 'beyazliste', usage: '', description: 'Beyaz listeyi g√∂sterir' },
          { name: 'beyazlisteekle', usage: '<kullanƒ±cƒ±-id>', description: 'Beyaz listeye ekler' },
          { name: 'beyazlistesil', usage: '<kullanƒ±cƒ±-id>', description: 'Beyaz listeden √ßƒ±karƒ±r' },
          { name: 'yedekle', usage: '', description: 'Sunucu yedeƒüi alƒ±r' },
          { name: 'geriy√ºkle', usage: '<eksik|tam>', description: 'Sunucu yedeƒüini y√ºkler' }
        ],
        bilgi: [
          { name: 'bilgi', usage: '[kullanƒ±cƒ±]', description: 'Kullanƒ±cƒ± veya sunucu bilgisi' },
          { name: 'avatar', usage: '[kullanƒ±cƒ±]', description: 'Kullanƒ±cƒ±nƒ±n avatarƒ±nƒ± g√∂sterir' },
          { name: 'ping', usage: '', description: 'Botun ping deƒüerini g√∂sterir' },
          { name: 'mute-liste', usage: '', description: 'Susturulanlarƒ± listeler' }
        ]
      };

      
      if (args[0]) {
        const categoryName = args[0].toLowerCase();
        const category = categories[categoryName];
        
        if (!category) {
          return message.reply('Ge√ßersiz kategori! Kategoriler: moderasyon, yonetim, bilgi');
        }
        
        const embed = new EmbedBuilder()
          .setColor(0x0099FF)
          .setTitle(`ü§ñ ${categoryName.charAt(0).toUpperCase() + categoryName.slice(1)} Komutlarƒ±`)
          .setDescription(`Prefix: **${CONFIG.prefix}**`)
          .setTimestamp();
        
        category.forEach(command => {
          embed.addFields({
            name: `${CONFIG.prefix}${command.name} ${command.usage}`,
            value: command.description
          });
        });
        
        return message.channel.send({ embeds: [embed] });
      }
      
      
      const embed = new EmbedBuilder()
        .setColor(0x0099FF)
        .setTitle('ü§ñ Yardƒ±m Men√ºs√º')
        .setDescription(`Prefix: **${CONFIG.prefix}**\nKomut kategorileri i√ßin ${CONFIG.prefix}yardim [kategori] yazƒ±n.`)
        .addFields(
          { name: 'üìã Kategoriler', value: '`moderasyon`, `yonetim`, `bilgi`' },
          { name: 'üîß √ñrnek Kullanƒ±m', value: `${CONFIG.prefix}yardim moderasyon` }
        )
        .setTimestamp();
      
      message.channel.send({ embeds: [embed] });
    }
  },
  {
    name: 'ban',
    description: 'Kullanƒ±cƒ±yƒ± banlar',
    permissions: [PermissionFlagsBits.BanMembers],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}ban [kullanƒ±cƒ±] [sebep]`);
      }
      
      const targetId = args[0].replace(/[<@!>]/g, '');
      const reason = args.slice(1).join(' ') || 'Sebep belirtilmedi';
      
      try {
        await message.guild.members.ban(targetId, { reason: reason });
        
        const embed = new EmbedBuilder()
          .setColor(0xff5555)
          .setTitle('üî® Ban')
          .addFields(
            { name: 'Kullanƒ±cƒ±', value: `${mention(targetId)} (${targetId})`, inline: true },
            { name: 'Yetkili', value: `${mention(message.author.id)} (${message.author.id})`, inline: true },
            { name: 'Sebep', value: reason, inline: false }
          )
          .setTimestamp();
        
        await sendLog(message.guild, embed);
        await message.reply(`‚úÖ ${targetId} banlandƒ±.`);
      } catch (error) {
        console.error('Ban error:', error);
        await message.reply('‚ùå Kullanƒ±cƒ± banlanamadƒ±. Yetkim olmayabilir.');
      }
    }
  },
  {
    name: 'unban',
    description: 'Banƒ± kaldƒ±rƒ±r',
    permissions: [PermissionFlagsBits.BanMembers],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}unban [kullanƒ±cƒ±-id]`);
      }
      
      const id = args[0];
      
      try {
        await message.guild.members.unban(id);
        
        const embed = new EmbedBuilder()
          .setColor(0x77dd77)
          .setTitle('‚ôªÔ∏è Unban')
          .addFields(
            { name: 'Kullanƒ±cƒ±', value: `${mention(id)} (${id})`, inline: true },
            { name: 'Yetkili', value: `${mention(message.author.id)} (${message.author.id})`, inline: true }
          )
          .setTimestamp();
        
        await sendLog(message.guild, embed);
        await message.reply(`‚úÖ ${id} banƒ± kaldƒ±rƒ±ldƒ±.`);
      } catch (error) {
        console.error('Unban error:', error);
        await message.reply('‚ùå Ban kaldƒ±rƒ±lamadƒ±. Kullanƒ±cƒ± banlƒ± olmayabilir.');
      }
    }
  },
  {
    name: 'kick',
    description: 'Kullanƒ±cƒ±yƒ± atar',
    permissions: [PermissionFlagsBits.KickMembers],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}kick [kullanƒ±cƒ±] [sebep]`);
      }
      
      const targetId = args[0].replace(/[<@!>]/g, '');
      const reason = args.slice(1).join(' ') || 'Sebep belirtilmedi';
      
      try {
        const target = await message.guild.members.fetch(targetId);
        await target.kick(reason);
        
        const embed = new EmbedBuilder()
          .setColor(0xffaa00)
          .setTitle('üë¢ Kick')
          .addFields(
            { name: 'Kullanƒ±cƒ±', value: `${mention(targetId)} (${targetId})`, inline: true },
            { name: 'Yetkili', value: `${mention(message.author.id)} (${message.author.id})`, inline: true },
            { name: 'Sebep', value: reason, inline: false }
          )
          .setTimestamp();
        
        await sendLog(message.guild, embed);
        await message.reply(`‚úÖ ${targetId} atƒ±ldƒ±.`);
      } catch (error) {
        console.error('Kick error:', error);
        await message.reply('‚ùå Kullanƒ±cƒ± atƒ±lamadƒ±. Yetkim olmayabilir.');
      }
    }
  },
  {
    name: 'mute',
    description: 'Kullanƒ±cƒ±yƒ± susturur',
    permissions: [PermissionFlagsBits.ModerateMembers],
    async execute(client, message, args) {
      if (!CONFIG.autoMute) {
        return message.reply('‚ùå Otomatik mute sistemi ≈üu anda kapalƒ±.');
      }
      
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}mute [kullanƒ±cƒ±] [s√ºre] [sebep]`);
      }
      
      const targetId = args[0].replace(/[<@!>]/g, '');
      
      let durationMs = null;
      let reason = 'Sebep belirtilmedi';
      
      if (args[1]) {
        durationMs = parseDuration(args[1]);
        if (durationMs) {
          reason = args.slice(2).join(' ') || reason;
        } else {
          reason = args.slice(1).join(' ') || reason;
        }
      }
      
      await applyMute(message.guild, message.member, targetId, durationMs, reason);
      await message.reply(`‚úÖ ${targetId} susturuldu (${durationMs ? msToDuration(durationMs) : 'sƒ±nƒ±rsƒ±z'}).`);
    }
  },
  {
    name: 'unmute',
    description: 'Susturmayƒ± kaldƒ±rƒ±r',
    permissions: [PermissionFlagsBits.ModerateMembers],
    async execute(client, message, args) {
      if (!CONFIG.autoMute) {
        return message.reply('‚ùå Otomatik mute sistemi ≈üu anda kapalƒ±.');
      }
      
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}unmute [kullanƒ±cƒ±]`);
      }
      
      const targetId = args[0].replace(/[<@!>]/g, '');
      await removeMute(message.guild, message.member, targetId);
      await message.reply(`‚úÖ ${targetId} susturulmasƒ± kaldƒ±rƒ±ldƒ±.`);
    }
  },
  {
    name: 'uyar',
    description: 'Kullanƒ±cƒ±ya uyarƒ± verir',
    permissions: [PermissionFlagsBits.ModerateMembers],
    async execute(client, message, args) {
      if (!CONFIG.warningSystem) {
        return message.reply('‚ùå Uyarƒ± sistemi ≈üu anda kapalƒ±.');
      }
      
      if (args.length < 2) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}uyar [kullanƒ±cƒ±] [sebep]`);
      }
      
      const targetId = args[0].replace(/[<@!>]/g, '');
      const reason = args.slice(1).join(' ');
      
      await addWarning(message.guild, message.member, targetId, reason);
      await message.reply(`‚úÖ ${targetId} kullanƒ±cƒ±sƒ±na uyarƒ± verildi.`);
    }
  },
  {
    name: 'uyarƒ±kaldir',
    description: 'Uyarƒ±yƒ± kaldƒ±rƒ±r',
    permissions: [PermissionFlagsBits.ModerateMembers],
    async execute(client, message, args) {
      if (!CONFIG.warningSystem) {
        return message.reply('‚ùå Uyarƒ± sistemi ≈üu anda kapalƒ±.');
      }
      
      if (args.length < 2) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}uyarƒ±kaldir [kullanƒ±cƒ±] [numara]`);
      }
      
      const targetId = args[0].replace(/[<@!>]/g, '');
      const warningIndex = parseInt(args[1]);
      
      const success = await removeWarning(message.guild, message.member, targetId, warningIndex);
      if (success) {
        await message.reply(`‚úÖ ${targetId} kullanƒ±cƒ±sƒ±ndan ${warningIndex}. uyarƒ± kaldƒ±rƒ±ldƒ±.`);
      } else {
        await message.reply('‚ùå Uyarƒ± kaldƒ±rƒ±lamadƒ±. Ge√ßersiz kullanƒ±cƒ± veya uyarƒ± numarasƒ±.');
      }
    }
  },
  {
    name: 'uyarƒ±lar',
    description: 'Kullanƒ±cƒ±nƒ±n uyarƒ±larƒ±nƒ± g√∂sterir',
    permissions: [PermissionFlagsBits.ModerateMembers],
    async execute(client, message, args) {
      if (!CONFIG.warningSystem) {
        return message.reply('‚ùå Uyarƒ± sistemi ≈üu anda kapalƒ±.');
      }
      
      const targetId = args.length > 0 ? args[0].replace(/[<@!>]/g, '') : message.author.id;
      ensureGuildStructure(warnings, message.guild.id);
      
      const userWarnings = warnings.guilds[message.guild.id].records[targetId] || [];
      
      if (userWarnings.length === 0) {
        return message.reply(`${mention(targetId)} kullanƒ±cƒ±sƒ±nƒ±n hi√ß uyarƒ±sƒ± yok.`);
      }
      
      const embed = new EmbedBuilder()
        .setColor(0xffaa00)
        .setTitle(`‚ö†Ô∏è ${mention(targetId)} Uyarƒ±larƒ±`)
        .setDescription(userWarnings.map((warning, index) => 
          `**${index + 1}.** ${warning.reason} - <@${warning.moderatorId}> - ${new Date(warning.time).toLocaleString('tr-TR')}`
        ).join('\n'))
        .setTimestamp();
      
      await message.channel.send({ embeds: [embed] });
    }
  },
  {
    name: 'temizle',
    description: 'Mesajlarƒ± siler',
    permissions: [PermissionFlagsBits.ManageMessages],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}temizle [miktar]`);
      }
      
      const amount = parseInt(args[0]);
      if (isNaN(amount) || amount < 1 || amount > 100) {
        return message.reply('L√ºtfen 1-100 arasƒ±nda ge√ßerli bir sayƒ± girin.');
      }
      
      try {
        await message.channel.bulkDelete(amount, true);
        const embed = new EmbedBuilder()
          .setColor(0x00ff00)
          .setTitle('üßπ Mesajlar Silindi')
          .setDescription(`${amount} mesaj ${mention(message.author.id)} tarafƒ±ndan silindi.`)
          .setTimestamp();
        
        await message.channel.send({ embeds: [embed] });
      } catch (error) {
        console.error('Message deletion error:', error);
        await message.reply('‚ùå Mesajlar silinemedi. 14 g√ºnden eski mesajlar silinemez.');
      }
    }
  },
  {
    name: 'yava≈ümod',
    description: 'Kanal i√ßin yava≈ü mod ayarlar',
    permissions: [PermissionFlagsBits.ManageChannels],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}yava≈ümod [saniye]`);
      }
      
      const seconds = parseInt(args[0]);
      if (isNaN(seconds) || seconds < 0 || seconds > 21600) {
        return message.reply('L√ºtfen 0-21600 arasƒ±nda ge√ßerli bir saniye deƒüeri girin.');
      }
      
      try {
        await message.channel.setRateLimitPerUser(seconds);
        await message.reply(`‚úÖ Kanal yava≈ü modu ${seconds} saniye olarak ayarlandƒ±.`);
      } catch (error) {
        console.error('Slow mode error:', error);
        await message.reply('‚ùå Yava≈ü mod ayarlanamadƒ±.');
      }
    }
  },
  {
    name: 'kilitle',
    description: 'Kanalƒ± kilitler',
    permissions: [PermissionFlagsBits.ManageChannels],
    async execute(client, message, args) {
      const reason = args.join(' ') || 'Belirtilmedi';
      
      try {
        await message.channel.permissionOverwrites.edit(message.guild.roles.everyone, {
          SendMessages: false
        }, { reason: `Kilitlendi: ${reason}` });
        
        const embed = new EmbedBuilder()
          .setColor(0xff0000)
          .setTitle('üîí Kanal Kilitlendi')
          .setDescription(`Bu kanal ${mention(message.author.id)} tarafƒ±ndan kilitlendi.`)
          .addFields({ name: 'Sebep', value: reason })
          .setTimestamp();
        
        await message.channel.send({ embeds: [embed] });
      } catch (error) {
        console.error('Channel lock error:', error);
        await message.reply('‚ùå Kanal kilitlenemedi.');
      }
    }
  },
  {
    name: 'kilida√ß',
    description: 'Kanal kilidini a√ßar',
    permissions: [PermissionFlagsBits.ManageChannels],
    async execute(client, message, args) {
      const reason = args.join(' ') || 'Belirtilmedi';
      
      try {
        await message.channel.permissionOverwrites.edit(message.guild.roles.everyone, {
          SendMessages: null
        }, { reason: `Kilidi a√ßƒ±ldƒ±: ${reason}` });
        
        const embed = new EmbedBuilder()
          .setColor(0x00ff00)
          .setTitle('üîì Kanal Kilidi A√ßƒ±ldƒ±')
          .setDescription(`Bu kanalƒ±n kilidi ${mention(message.author.id)} tarafƒ±ndan a√ßƒ±ldƒ±.`)
          .addFields({ name: 'Sebep', value: reason })
          .setTimestamp();
        
        await message.channel.send({ embeds: [embed] });
      } catch (error) {
        console.error('Channel unlock error:', error);
        await message.reply('‚ùå Kanal kilidi a√ßƒ±lamadƒ±.');
      }
    }
  },
  {
    name: 'bilgi',
    description: 'Kullanƒ±cƒ± veya sunucu bilgisi',
    permissions: [],
    async execute(client, message, args) {
      const target = args.length > 0 
        ? message.mentions.users.first() || message.guild.members.cache.get(args[0])?.user 
        : message.author;
      
      if (!target) {
        return message.reply('Kullanƒ±cƒ± bulunamadƒ±.');
      }
      
      const member = message.guild.members.cache.get(target.id);
      
      const embed = new EmbedBuilder()
        .setColor(0x0099ff)
        .setTitle(`${target.tag} Bilgileri`)
        .setThumbnail(target.displayAvatarURL({ dynamic: true }))
        .addFields(
          { name: 'ID', value: target.id, inline: true },
          { name: 'Kullanƒ±cƒ± Adƒ±', value: target.username, inline: true },
          { name: 'Takma Ad', value: member?.nickname || 'Yok', inline: true },
          { name: 'Bot mu?', value: target.bot ? 'Evet' : 'Hayƒ±r', inline: true },
          { name: 'Hesap Olu≈üturma', value: `<t:${Math.floor(target.createdTimestamp / 1000)}:R>`, inline: true },
          { name: 'Sunucuya Katƒ±lma', value: member ? `<t:${Math.floor(member.joinedTimestamp / 1000)}:R>` : 'Bilinmiyor', inline: true }
        )
        .setTimestamp();
      
      if (member) {
        const roles = member.roles.cache
          .filter(role => role.id !== message.guild.id)
          .map(role => role.name)
          .join(', ') || 'Yok';
        
        embed.addFields({ name: 'Roller', value: roles, inline: false });
      }
      
      await message.channel.send({ embeds: [embed] });
    }
  },
  {
    name: 'avatar',
    description: 'Kullanƒ±cƒ±nƒ±n avatarƒ±nƒ± g√∂sterir',
    permissions: [],
    async execute(client, message, args) {
      const target = args.length > 0 
        ? message.mentions.users.first() || message.guild.members.cache.get(args[0])?.user 
        : message.author;
      
      if (!target) {
        return message.reply('Kullanƒ±cƒ± bulunamadƒ±.');
      }
      
      const embed = new EmbedBuilder()
        .setColor(0x0099ff)
        .setTitle(`${target.tag} Avatarƒ±`)
        .setImage(target.displayAvatarURL({ dynamic: true, size: 4096 }))
        .setTimestamp();
      
      await message.channel.send({ embeds: [embed] });
    }
  },
  {
    name: 'ping',
    description: 'Botun ping deƒüerini g√∂sterir',
    permissions: [],
    async execute(client, message, args) {
      const embed = new EmbedBuilder()
        .setColor(0x00ff00)
        .setTitle('üèì Pong!')
        .setDescription(`Botun ping deƒüeri: ${client.ws.ping}ms`)
        .setTimestamp();
      
      await message.channel.send({ embeds: [embed] });
    }
  },
  {
    name: 'beyazliste',
    description: 'Beyaz listeyi g√∂sterir',
    permissions: [PermissionFlagsBits.Administrator],
    async execute(client, message, args) {
      ensureGuildStructure(whitelist, message.guild.id);
      const list = whitelist.guilds[message.guild.id].users;
      
      const embed = new EmbedBuilder()
        .setColor(0x00ff88)
        .setTitle('üìã Beyaz Liste')
        .setDescription(list.length ? 
          list.map(id => `‚Ä¢ ${mention(id)} (${id})`).join('\n') : 
          'Bo≈ü'
        )
        .setTimestamp();
      
      await message.channel.send({ embeds: [embed] });
    }
  },
  {
    name: 'beyazlisteekle',
    description: 'Beyaz listeye ekler',
    permissions: [PermissionFlagsBits.Administrator],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}beyazlisteekle [kullanƒ±cƒ±-id]`);
      }
      
      const id = args[0];
      ensureGuildStructure(whitelist, message.guild.id);
      
      if (!whitelist.guilds[message.guild.id].users.includes(id)) {
        whitelist.guilds[message.guild.id].users.push(id);
        saveJSON(WHITELIST_FILE, whitelist);
        await message.reply(`‚úÖ ${id} beyaz listeye eklendi.`);
      } else {
        await message.reply(`‚ÑπÔ∏è ${id} zaten beyaz listede.`);
      }
    }
  },
  {
    name: 'beyazlistesil',
    description: 'Beyaz listeden √ßƒ±karƒ±r',
    permissions: [PermissionFlagsBits.Administrator],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}beyazlistesil [kullanƒ±cƒ±-id]`);
      }
      
      const id = args[0];
      ensureGuildStructure(whitelist, message.guild.id);
      
      const index = whitelist.guilds[message.guild.id].users.indexOf(id);
      if (index !== -1) {
        whitelist.guilds[message.guild.id].users.splice(index, 1);
        saveJSON(WHITELIST_FILE, whitelist);
        await message.reply(`‚úÖ ${id} beyaz listeden √ßƒ±karƒ±ldƒ±.`);
      } else {
        await message.reply(`‚ÑπÔ∏è ${id} beyaz listede bulunamadƒ±.`);
      }
    }
  },
  {
    name: 'yedekle',
    description: 'Sunucu yedeƒüi alƒ±r',
    permissions: [PermissionFlagsBits.Administrator],
    async execute(client, message, args) {
      if (!CONFIG.backupSystem) {
        return message.reply('‚ùå Yedekleme sistemi ≈üu anda kapalƒ±.');
      }
      
      const msg = await message.reply('Yedek alƒ±nƒ±yor...');
      const file = await backupGuild(message.guild);
      if (file) {
        await msg.edit(`‚úÖ Yedek alƒ±ndƒ±: \`${file}\``);
      } else {
        await msg.edit('‚ùå Yedek alƒ±namadƒ±.');
      }
    }
  },
  {
    name: 'geriy√ºkle',
    description: 'Sunucu yedeƒüini y√ºkler',
    permissions: [PermissionFlagsBits.Administrator],
    async execute(client, message, args) {
      if (!CONFIG.backupSystem) {
        return message.reply('‚ùå Yedekleme sistemi ≈üu anda kapalƒ±.');
      }
      
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}geriy√ºkle [eksik|tam]`);
      }
      
      const mode = args[0];
      if (!['eksik', 'tam'].includes(mode)) {
        return message.reply('Ge√ßersiz mod. "eksik" veya "tam" kullanƒ±n.');
      }
      
      const msg = await message.reply(`Yedek y√ºkleniyor (${mode})...`);
      await restoreGuild(message.guild, mode);
      await msg.edit(`‚úÖ Yedek y√ºklendi (${mode}).`);
    }
  },
  {
    name: 'mute-liste',
    description: 'Susturulanlarƒ± listeler',
    permissions: [PermissionFlagsBits.ModerateMembers],
    async execute(client, message, args) {
      if (!CONFIG.autoMute) {
        return message.reply('‚ùå Otomatik mute sistemi ≈üu anda kapalƒ±.');
      }
      
      ensureGuildStructure(mutes, message.guild.id);
      const records = mutes.guilds[message.guild.id].records || {};
      
      const list = Object.entries(records).map(([id, data]) =>
        `‚Ä¢ ${mention(id)} (${id}) ‚Äî ${data.reason || 'Sebep yok'}${
          data.endTime ? ` (kalan: ${msToDuration(data.endTime - Date.now())})` : ' (sƒ±nƒ±rsƒ±z)'
        }`
      );
      
      const embed = new EmbedBuilder()
        .setColor(0xffcc00)
        .setTitle('üîá Susturulanlar')
        .setDescription(list.length ? list.join('\n') : 'Bo≈ü')
        .setTimestamp();
      
      await message.channel.send({ embeds: [embed] });
    }
  },
  {
    name: 'rolver',
    description: 'Kullanƒ±cƒ±ya rol verir',
    permissions: [PermissionFlagsBits.ManageRoles],
    async execute(client, message, args) {
      if (args.length < 2) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}rolver [kullanƒ±cƒ±] [rol]`);
      }
      
      const targetId = args[0].replace(/[<@!>]/g, '');
      const roleName = args.slice(1).join(' ');
      
      const role = message.guild.roles.cache.find(r => r.name.toLowerCase() === roleName.toLowerCase());
      if (!role) {
        return message.reply('Rol bulunamadƒ±.');
      }
      
      const target = await message.guild.members.fetch(targetId).catch(() => null);
      if (!target) {
        return message.reply('Kullanƒ±cƒ± bulunamadƒ±.');
      }
      
      try {
        await target.roles.add(role);
        await message.reply(`‚úÖ ${mention(targetId)} kullanƒ±cƒ±sƒ±na "${role.name}" rol√º verildi.`);
      } catch (error) {
        console.error('Role add error:', error);
        await message.reply('‚ùå Rol verilemedi. Yetkim olmayabilir.');
      }
    }
  },
  {
    name: 'rolal',
    description: 'Kullanƒ±cƒ±dan rol alƒ±r',
    permissions: [PermissionFlagsBits.ManageRoles],
    async execute(client, message, args) {
      if (args.length < 2) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}rolal [kullanƒ±cƒ±] [rol]`);
      }
      
      const targetId = args[0].replace(/[<@!>]/g, '');
      const roleName = args.slice(1).join(' ');
      
      const role = message.guild.roles.cache.find(r => r.name.toLowerCase() === roleName.toLowerCase());
      if (!role) {
        return message.reply('Rol bulunamadƒ±.');
      }
      
      const target = await message.guild.members.fetch(targetId).catch(() => null);
      if (!target) {
        return message.reply('Kullanƒ±cƒ± bulunamadƒ±.');
      }
      
      try {
        await target.roles.remove(role);
        await message.reply(`‚úÖ ${mention(targetId)} kullanƒ±cƒ±sƒ±ndan "${role.name}" rol√º alƒ±ndƒ±.`);
      } catch (error) {
        console.error('Role remove error:', error);
        await message.reply('‚ùå Rol alƒ±namadƒ±. Yetkim olmayabilir.');
      }
    }
  },
  {
    name: 'kanalolu≈ütur',
    description: 'Yeni kanal olu≈üturur',
    permissions: [PermissionFlagsBits.ManageChannels],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}kanalolu≈ütur [isim] [tip]`);
      }
      
      const name = args[0];
      const type = args[1] || 'text';
      
      let channelType;
      switch (type.toLowerCase()) {
        case 'text':
        case 'metin':
          channelType = ChannelType.GuildText;
          break;
        case 'voice':
        case 'ses':
          channelType = ChannelType.GuildVoice;
          break;
        case 'category':
        case 'kategori':
          channelType = ChannelType.GuildCategory;
          break;
        default:
          return message.reply('Ge√ßersiz kanal tipi. text, voice veya category kullanƒ±n.');
      }
      
      try {
        const channel = await message.guild.channels.create({
          name: name,
          type: channelType
        });
        
        await message.reply(`‚úÖ "${channel.name}" kanalƒ± olu≈üturuldu.`);
      } catch (error) {
        console.error('Channel creation error:', error);
        await message.reply('‚ùå Kanal olu≈üturulamadƒ±.');
      }
    }
  },
  {
    name: 'kanalsil',
    description: 'Kanal siler',
    permissions: [PermissionFlagsBits.ManageChannels],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}kanalsil [kanal]`);
      }
      
      const channelName = args.join(' ');
      const channel = message.guild.channels.cache.find(c => 
        c.name.toLowerCase() === channelName.toLowerCase()
      );
      
      if (!channel) {
        return message.reply('Kanal bulunamadƒ±.');
      }
      
      try {
        await channel.delete();
        await message.reply(`‚úÖ "${channel.name}" kanalƒ± silindi.`);
      } catch (error) {
        console.error('Channel deletion error:', error);
        await message.reply('‚ùå Kanal silinemedi.');
      }
    }
  },
  {
    name: 'rololu≈ütur',
    description: 'Yeni rol olu≈üturur',
    permissions: [PermissionFlagsBits.ManageRoles],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}rololu≈ütur [isim] [renk]`);
      }
      
      const name = args[0];
      const color = args[1] ? args[1].replace('#', '') : null;
      
      try {
        const role = await message.guild.roles.create({
          name: name,
          color: color ? parseInt(color, 16) : null
        });
        
        await message.reply(`‚úÖ "${role.name}" rol√º olu≈üturuldu.`);
      } catch (error) {
        console.error('Role creation error:', error);
        await message.reply('‚ùå Rol olu≈üturulamadƒ±.');
      }
    }
  },
  {
    name: 'rolsil',
    description: 'Rol siler',
    permissions: [PermissionFlagsBits.ManageRoles],
    async execute(client, message, args) {
      if (args.length < 1) {
        return message.reply(`Kullanƒ±m: ${CONFIG.prefix}rolsil [rol]`);
      }
      
      const roleName = args.join(' ');
      const role = message.guild.roles.cache.find(r => 
        r.name.toLowerCase() === roleName.toLowerCase()
      );
      
      if (!role) {
        return message.reply('Rol bulunamadƒ±.');
      }
      
      try {
        await role.delete();
        await message.reply(`‚úÖ "${role.name}" rol√º silindi.`);
      } catch (error) {
        console.error('Role deletion error:', error);
        await message.reply('‚ùå Rol silinemedi.');
      }
    }
  }
];


commands.forEach(command => {
  client.commands.set(command.name, command);
});


client.on('ready', async () => {
  console.log(`‚úÖ ${client.user.tag} olarak giri≈ü yapƒ±ldƒ±.`);
  console.log(`üìã Yapƒ±landƒ±rma durumu:`);
  console.log(`  - Otomatik Mute: ${CONFIG.autoMute ? 'A√ßƒ±k' : 'Kapalƒ±'}`);
  console.log(`  - Uyarƒ± Sistemi: ${CONFIG.warningSystem ? 'A√ßƒ±k' : 'Kapalƒ±'}`);
  console.log(`  - Otomatik Loglama: ${CONFIG.autoLogging ? 'A√ßƒ±k' : 'Kapalƒ±'}`);
  console.log(`  - Yedekleme Sistemi: ${CONFIG.backupSystem ? 'A√ßƒ±k' : 'Kapalƒ±'}`);
  console.log(`  - Davet Engelleme: ${CONFIG.inviteBlock ? 'A√ßƒ±k' : 'Kapalƒ±'}`);
  console.log(`  - Spam Koruma: ${CONFIG.spamProtection ? 'A√ßƒ±k' : 'Kapalƒ±'}`);
  console.log(`  - K√ºf√ºr Engelleme: ${CONFIG.profanityFilter ? 'A√ßƒ±k' : 'Kapalƒ±'}`);
  console.log(`  - Link Engelleme: ${CONFIG.linkBlock ? 'A√ßƒ±k' : 'Kapalƒ±'}`);
  
  
  await client.user.setPresence({
    activities: [{ name: `By Zywexx | ${CONFIG.prefix}yardim`, type: ActivityType.Playing }],
    status: 'online'
  });
  
  
  for (const [guildId, guild] of client.guilds.cache) {
    await createMuteRole(guild);
    
    
    ensureGuildStructure(mutes, guildId);
    const records = mutes.guilds[guildId].records || {};
    
    for (const [userId, data] of Object.entries(records)) {
      
      if (data.endTime && Date.now() >= data.endTime) {
        await removeMute(guild, null, userId, 'S√ºre doldu (ba≈ülangƒ±√ß senkronizasyonu)');
        continue;
      }
      
     
      const member = await guild.members.fetch(userId).catch(() => null);
      const role = guild.roles.cache.find(r => r.name === CONFIG.muteRoleName);
      
      if (member && role && !member.roles.cache.has(role.id)) {
        await member.roles.add(role, 'Senkronizasyon: kayƒ±tlƒ± mute').catch(() => {});
      }
    }
  }
});


client.on('guildCreate', async (guild) => {
  try {
    const allowed = (process.env.ALLOWED_GUILD_IDS || '')
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
    
    if (allowed.length && !allowed.includes(guild.id)) {
      await guild.leave();
    } else {
      await createMuteRole(guild);
    }
  } catch (error) {
    console.error('Guild join error:', error);
  }
});


client.on('channelCreate', async (channel) => {
  await applyMuteRoleToNewChannel(channel);
});


client.on('messageCreate', async (message) => {
  
  if (message.author.bot) return;
  
  
  if (message.content.startsWith(CONFIG.prefix)) {
    const args = message.content.slice(CONFIG.prefix.length).trim().split(/ +/);
    const commandName = args.shift().toLowerCase();
    
    const command = client.commands.get(commandName);
    
    if (command) {
      
      const hasPermission = command.permissions.length > 0 && 
        !command.permissions.some(perm => message.member.permissions.has(perm));
      
      if (hasPermission) {
        return message.reply('‚õî Bu komutu kullanma yetkiniz yok.');
      }
      
      try {
        await command.execute(client, message, args);
      } catch (error) {
        console.error(`Command error (${commandName}):`, error);
        await message.reply('‚ùå Komut √ßalƒ±≈ütƒ±rƒ±lƒ±rken bir hata olu≈ütu.');
      }
    }
  }
  
  
  const guild = message.guild;
  if (!guild) return;
  
  
  if (isWhitelisted(guild.id, message.author.id)) return;
  
  
  if (CONFIG.inviteBlock) {
    const inviteRegex = /(discord\.gg|discord\.com\/invite)\/[A-Za-z0-9-]+/i;
    if (inviteRegex.test(message.content)) {
      try {
        await message.delete();
        await message.channel.send(`${mention(message.author.id)} davet linkleri bu sunucuda yasak.`);
        
        const embed = new EmbedBuilder()
          .setColor(0xdd4444)
          .setTitle('üö´ Davet Linki Engellendi')
          .addFields(
            { name: 'Kullanƒ±cƒ±', value: `${mention(message.author.id)} (${message.author.id})`, inline: true },
            { name: 'Kanal', value: `${message.channel}`, inline: true },
            { name: 'ƒ∞√ßerik', value: message.content.slice(0, 400) }
          )
          .setTimestamp();
        
        await sendLog(guild, embed);
      } catch (error) {
        console.error('Invite block error:', error);
      }
    }
  }
  
  
  if (CONFIG.profanityFilter) {
    const hasProfanity = CONFIG.profanities.some(profanity => 
      message.content.toLowerCase().includes(profanity.toLowerCase())
    );
    
    if (hasProfanity) {
      try {
        await message.delete();
        await message.channel.send(`${mention(message.author.id)} l√ºtfen k√ºf√ºr etmeyin.`);
        
        const embed = new EmbedBuilder()
          .setColor(0xdd4444)
          .setTitle('üö´ K√ºf√ºr Engellendi')
          .addFields(
            { name: 'Kullanƒ±cƒ±', value: `${mention(message.author.id)} (${message.author.id})`, inline: true },
            { name: 'Kanal', value: `${message.channel}`, inline: true },
            { name: 'ƒ∞√ßerik', value: message.content.slice(0, 400) }
          )
          .setTimestamp();
        
        await sendLog(guild, embed);
      } catch (error) {
        console.error('Profanity filter error:', error);
      }
    }
  }
  
  
  if (CONFIG.linkBlock) {
    const linkRegex = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/i;
    if (linkRegex.test(message.content)) {
      try {
        await message.delete();
        await message.channel.send(`${mention(message.author.id)} linkler bu sunucuda yasak.`);
        
        const embed = new EmbedBuilder()
          .setColor(0xdd4444)
          .setTitle('üö´ Link Engellendi')
          .addFields(
            { name: 'Kullanƒ±cƒ±', value: `${mention(message.author.id)} (${message.author.id})`, inline: true },
            { name: 'Kanal', value: `${message.channel}`, inline: true },
            { name: 'ƒ∞√ßerik', value: message.content.slice(0, 400) }
          )
          .setTimestamp();
        
        await sendLog(guild, embed);
      } catch (error) {
        console.error('Link block error:', error);
      }
    }
  }
  
  
  if (CONFIG.spamProtection) {
    const key = `${guild.id}-${message.author.id}`;
    
    if (!client.spamTracker) {
      client.spamTracker = new Map();
    }
    
    if (!client.spamTracker.has(key)) {
      client.spamTracker.set(key, {
        messages: [],
        interval: CONFIG.spamInterval,
        limit: CONFIG.spamLimit
      });
    }
    
    const userData = client.spamTracker.get(key);
    const now = Date.now();
    
    
    userData.messages = userData.messages.filter(time => now - time < userData.interval);
    
    
    userData.messages.push(now);
    
    
    if (userData.messages.length >= userData.limit) {
      try {
        
        const messagesToDelete = await message.channel.messages.fetch({ limit: 10 });
        const userMessages = messagesToDelete.filter(m => m.author.id === message.author.id);
        await message.channel.bulkDelete(userMessages);
        
        
        await applyMute(guild, guild.me, message.author.id, 5 * 60 * 1000, 'Spam yapma');
        
        await message.channel.send(`${mention(message.author.id)} spam yaptƒ±ƒüƒ±nƒ±z i√ßin 5 dakika susturuldunuz.`);
        
        const embed = new EmbedBuilder()
          .setColor(0xffaa00)
          .setTitle('‚ö†Ô∏è Spam Engellendi')
          .addFields(
            { name: 'Kullanƒ±cƒ±', value: `${mention(message.author.id)} (${message.author.id})`, inline: true },
            { name: 'Kanal', value: `${message.channel}`, inline: true },
            { name: 'Eylem', value: '5 dakika susturuldu', inline: false }
          )
          .setTimestamp();
        
        await sendLog(guild, embed);
      } catch (error) {
        console.error('Spam protection error:', error);
      }
    }
  }
});


client.on('channelDelete', async (channel) => {
  try {
    const logs = await channel.guild.fetchAuditLogs({
      type: AuditLogEvent.ChannelDelete,
      limit: 1
    }).catch(() => null);
    
    const entry = logs?.entries.first();
    if (!entry) return;
    
    if (addAction(entry.executor.id, 'channel', CONFIG.channelDeleteLimit)) {
      await punishUser(channel.guild, entry.executor.id, 'Kanal silme limiti a≈üƒ±ldƒ±');
    }
    
    const embed = new EmbedBuilder()
      .setColor(0xff6666)
      .setTitle('üóëÔ∏è Kanal Silme')
      .addFields(
        { name: 'Kanal', value: `#${channel.name} (${channel.id})`, inline: true },
        { name: 'Silen', value: `${mention(entry.executor.id)} (${entry.executor.id})`, inline: true }
      )
      .setTimestamp();
    
    await sendLog(channel.guild, embed);
  } catch (error) {
    console.error('Channel delete log error:', error);
  }
});


client.on('roleDelete', async (role) => {
  try {
    const logs = await role.guild.fetchAuditLogs({
      type: AuditLogEvent.RoleDelete,
      limit: 1
    }).catch(() => null);
    
    const entry = logs?.entries.first();
    if (!entry) return;
    
    if (addAction(entry.executor.id, 'role', CONFIG.roleDeleteLimit)) {
      await punishUser(role.guild, entry.executor.id, 'Rol silme limiti a≈üƒ±ldƒ±');
    }
    
    const embed = new EmbedBuilder()
      .setColor(0xff6666)
      .setTitle('üé≠ Rol Silme')
      .addFields(
        { name: 'Rol', value: `${role.name} (${role.id})`, inline: true },
        { name: 'Silen', value: `${mention(entry.executor.id)} (${entry.executor.id})`, inline: true }
      )
      .setTimestamp();
    
    await sendLog(role.guild, embed);
  } catch (error) {
    console.error('Role delete log error:', error);
  }
});


client.on('roleCreate', async (role) => {
  if (!CONFIG.dangerousRoleGuard) return;
  
  try {
    if (CONFIG.forbiddenPermissions.some(perm => role.permissions.has(perm))) {
      await role.setPermissions(0n, 'Yasaklƒ± izinler kaldƒ±rƒ±ldƒ±').catch(() => {});
      
      const logs = await role.guild.fetchAuditLogs({
        type: AuditLogEvent.RoleCreate,
        limit: 1
      }).catch(() => null);
      
      const entry = logs?.entries.first();
      if (!entry) return;
      
      if (addAction(entry.executor.id, 'permission', CONFIG.forbiddenPermissionLimit)) {
        await punishUser(role.guild, entry.executor.id, 'Yasaklƒ± izin verme limiti a≈üƒ±ldƒ±');
      }
      
      const embed = new EmbedBuilder()
        .setColor(0xffaa00)
        .setTitle('‚ö†Ô∏è Tehlikeli ƒ∞zin Temizlendi (Rol Olu≈üturma)')
        .addFields(
          { name: 'Rol', value: `${role.name} (${role.id})`, inline: true },
          { name: 'ƒ∞≈ülemi Yapan', value: `${mention(entry.executor.id)} (${entry.executor.id})`, inline: true }
        )
        .setTimestamp();
      
      await sendLog(role.guild, embed);
    }
  } catch (error) {
    console.error('Role create protection error:', error);
  }
});


client.on('roleUpdate', async (oldRole, newRole) => {
  if (!CONFIG.dangerousRoleGuard) return;
  
  try {
    if (CONFIG.forbiddenPermissions.some(perm => newRole.permissions.has(perm))) {
      await newRole.setPermissions(oldRole.permissions, 'Yasaklƒ± izinler geri alƒ±ndƒ±').catch(() => {});
      
      const logs = await newRole.guild.fetchAuditLogs({
        type: AuditLogEvent.RoleUpdate,
        limit: 1
      }).catch(() => null);
      
      const entry = logs?.entries.first();
      if (!entry) return;
      
      if (addAction(entry.executor.id, 'permission', CONFIG.forbiddenPermissionLimit)) {
        await punishUser(newRole.guild, entry.executor.id, 'Yasaklƒ± izin verme limiti a≈üƒ±ldƒ±');
      }
      
      const embed = new EmbedBuilder()
        .setColor(0xffaa00)
        .setTitle('‚ö†Ô∏è Tehlikeli ƒ∞zin Geri Alƒ±ndƒ± (Rol G√ºncelleme)')
        .addFields(
          { name: 'Rol', value: `${newRole.name} (${newRole.id})`, inline: true },
          { name: 'ƒ∞≈ülemi Yapan', value: `${mention(entry.executor.id)} (${entry.executor.id})`, inline: true }
        )
        .setTimestamp();
      
      await sendLog(newRole.guild, embed);
    }
  } catch (error) {
    console.error('Role update protection error:', error);
  }
});


client.on('guildMemberAdd', async (member) => {
  if (!CONFIG.botAddProtection || !member.user.bot) return;
  
  try {
    const guild = member.guild;
    const logs = await guild.fetchAuditLogs({
      type: AuditLogEvent.BotAdd,
      limit: 1
    }).catch(() => null);
    
    const entry = logs?.entries.first();
    const executorId = entry?.executor?.id;
    if (!executorId) return;
    
    if (isWhitelisted(guild.id, executorId)) {
      const embed = new EmbedBuilder()
        .setColor(0x55ddaa)
        .setTitle('ü§ñ Bot Eklendi (Beyaz Liste)')
        .addFields(
          { name: 'Bot', value: `${mention(member.id)} (${member.id})`, inline: true },
          { name: 'Ekleyen', value: `${mention(executorId)} (${executorId})`, inline: true }
        )
        .setTimestamp();
      
      await sendLog(guild, embed);
      return;
    }
    
    
    await member.kick('Beyaz liste dƒ±≈üƒ± bot ekleme').catch(() => {});
    await punishUser(guild, executorId, 'Beyaz liste dƒ±≈üƒ± bot ekleme');
    
    const embed = new EmbedBuilder()
      .setColor(0xdd4444)
      .setTitle('‚õî Bot Ekleme Engellendi')
      .addFields(
        { name: 'Bot', value: `${mention(member.id)} (${member.id})`, inline: true },
        { name: 'Eklemeye √áalƒ±≈üan', value: `${mention(executorId)} (${executorId})`, inline: true }
      )
      .setTimestamp();
    
    await sendLog(guild, embed);
  } catch (error) {
    console.error('Bot add protection error:', error);
  }
});


client.on('guildBanAdd', async (ban) => {
  if (!CONFIG.boosterProtection && CONFIG.nonWhitelistBanLimit <= 0) return;
  
  try {
    const guild = ban.guild;
    const logs = await guild.fetchAuditLogs({
      type: AuditLogEvent.MemberBanAdd,
      limit: 1
    }).catch(() => null);
    
    const entry = logs?.entries.first();
    if (!entry) return;
    
    const executorId = entry.executor.id;
    const targetId = entry.target?.id;
    
    const member = await guild.members.fetch(targetId).catch(() => null);
    const isTargetBooster = !!member?.premiumSince;
    
    
    if (CONFIG.boosterProtection && isTargetBooster && !isWhitelisted(guild.id, executorId)) {
      await guild.members.unban(targetId, 'Booster korumasƒ±').catch(() => {});
      
      const logChannel = logChannel(guild);
      if (logChannel) {
        await logChannel.send({
          content: `${mention(executorId)} booster banlayamazsƒ±n. Tekrar denersen yaptƒ±rƒ±mlar uygulanƒ±r.`
        }).catch(() => {});
      }
      
      const embed = new EmbedBuilder()
        .setColor(0xffaa00)
        .setTitle('üõ°Ô∏è Booster Korumasƒ±: Ban Geri Alƒ±ndƒ±')
        .addFields(
          { name: 'Hedef', value: `${mention(targetId)} (${targetId})`, inline: true },
          { name: 'Deneyen', value: `${mention(executorId)} (${executorId})`, inline: true }
        )
        .setTimestamp();
      
      await sendLog(guild, embed);
      return;
    }
    
    
    if (!isWhitelisted(guild.id, executorId)) {
      ensureGuildStructure(bancount, guild.id);
      const count = bancount.guilds[guild.id].count;
      count[executorId] = (count[executorId] || 0) + 1;
      saveJSON(BANCOUNT_FILE, bancount);
      
      if (count[executorId] === 1) {
        const logChannel = logChannel(guild);
        if (logChannel) {
          await logChannel.send({
            content: `${mention(executorId)} uyarƒ±: Bir ki≈üiyi banladƒ±n. Bir ki≈üi daha banlarsan t√ºm rollerin alƒ±nacak.`
          }).catch(() => {});
        }
      } else if (count[executorId] >= CONFIG.nonWhitelistBanLimit) {
        await punishUser(guild, executorId, 'Ban limiti a≈üƒ±ldƒ±');
        count[executorId] = 0; 
        saveJSON(BANCOUNT_FILE, bancount);
      }
    }
    
    
    const embed = new EmbedBuilder()
      .setColor(0xcc3333)
      .setTitle('üî® Ban (Event)')
      .addFields(
        { name: 'Hedef', value: `${mention(targetId)} (${targetId})`, inline: true },
        { name: 'Yapan', value: `${mention(executorId)} (${executorId})`, inline: true }
      )
      .setTimestamp();
    
    await sendLog(guild, embed);
  } catch (error) {
    console.error('Ban add protection error:', error);
  }
});


client.on('guildUpdate', async (oldGuild, newGuild) => {
  if (!CONFIG.vanityProtection) return;
  
  try {
    ensureGuildStructure(vanityStore, newGuild.id);
    
    
    if (!vanityStore.guilds[newGuild.id].vanity && newGuild.vanityURLCode) {
      vanityStore.guilds[newGuild.id].vanity = newGuild.vanityURLCode;
      saveJSON(VANITY_FILE, vanityStore);
    }
    
    
    if (oldGuild.vanityURLCode !== newGuild.vanityURLCode) {
      const logs = await newGuild.fetchAuditLogs({
        type: AuditLogEvent.GuildUpdate,
        limit: 5
      }).catch(() => null);
      
      const entry = logs?.entries.find(e => 
        e.changes?.some(change => change.key === 'vanity_url_code')
      ) || logs?.entries.first();
      
      const executorId = entry?.executor?.id;
      const original = vanityStore.guilds[newGuild.id].vanity || oldGuild.vanityURLCode;
      
      
      if (executorId && executorId !== CONFIG.ownerID) {
        await newGuild.setVanityCode(original).catch(() => {});
        
        const member = await newGuild.members.fetch(executorId).catch(() => null);
        if (member) {
          await member.ban({ reason: 'Vanity URL koruma' }).catch(() => {});
        }
        
        const embed = new EmbedBuilder()
          .setColor(0xdd4444)
          .setTitle('üîí Vanity URL Koruma')
          .setDescription(`Vanity URL izinsiz deƒüi≈ütirildi, **eski haline getirildi** ve ${mention(executorId)} banlandƒ±.`)
          .setTimestamp();
        
        const logChannel = logChannel(newGuild);
        if (logChannel) {
          await logChannel.send({ embeds: [embed] }).catch(() => {});
        }
      } else {
        
        vanityStore.guilds[newGuild.id].vanity = newGuild.vanityURLCode;
        saveJSON(VANITY_FILE, vanityStore);
        
        const embed = new EmbedBuilder()
          .setColor(0x55ddaa)
          .setTitle('üîß Vanity URL G√ºncellendi')
          .addFields(
            { name: 'Eski', value: `${oldGuild.vanityURLCode || '‚Äî'}`, inline: true },
            { name: 'Yeni', value: `${newGuild.vanityURLCode || '‚Äî'}`, inline: true },
            { name: 'Yetkili', value: executorId ? `${mention(executorId)} (${executorId})` : 'Bilinmiyor', inline: false }
          )
          .setTimestamp();
        
        await sendLog(newGuild, embed);
      }
    }
  } catch (error) {
    console.error('Vanity URL protection error:', error);
  }
});


client.on('webhookUpdate', async (channel) => {
  if (!CONFIG.webhookProtection) return;
  
  try {
    const guild = channel.guild;
    const logs = await guild.fetchAuditLogs({
      type: AuditLogEvent.WebhookCreate,
      limit: 1
    }).catch(() => null);
    
    const entry = logs?.entries.first();
    if (!entry) return;
    
    if (!isWhitelisted(guild.id, entry.executor.id)) {
      
      const webhooks = await channel.fetchWebhooks();
      for (const webhook of webhooks.values()) {
        await webhook.delete().catch(() => {});
      }
      
      await punishUser(guild, entry.executor.id, 'ƒ∞zinsiz webhook olu≈üturma');
      
      const embed = new EmbedBuilder()
        .setColor(0xdd4444)
        .setTitle('‚õî Webhook Olu≈üturma Engellendi')
        .addFields(
          { name: 'Kanal', value: `${channel.name} (${channel.id})`, inline: true },
          { name: 'Yapan', value: `${mention(entry.executor.id)} (${entry.executor.id})`, inline: true }
        )
        .setTimestamp();
      
      await sendLog(guild, embed);
    }
  } catch (error) {
    console.error('Webhook protection error:', error);
  }
});


setInterval(async () => {
  try {
    for (const [guildId, guild] of client.guilds.cache) {
      ensureGuildStructure(mutes, guildId);
      const records = mutes.guilds[guildId].records || {};
      
      for (const [userId, data] of Object.entries(records)) {
        if (data.endTime && Date.now() >= data.endTime) {
          await removeMute(guild, null, userId, 'S√ºre doldu (otomatik)');
        }
      }
    }
  } catch (error) {
    console.error('Mute check interval error:', error);
  }
}, 30 * 1000);


client.login(process.env.TOKEN).catch(error => {
  console.error('Login failed:', error);
});